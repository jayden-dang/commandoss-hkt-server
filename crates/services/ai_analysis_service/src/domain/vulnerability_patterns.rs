use crate::domain::analysis_models::{VulnerabilityFinding, VulnerabilityType, Severity};
use crate::error::{Error, Result};
use regex::Regex;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityPattern {
    pub id: String,
    pub name: String,
    pub description: String,
    pub vulnerability_type: VulnerabilityType,
    pub severity: Severity,
    pub confidence_base: f64,
    pub pattern: PatternRule,
    pub recommendation: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PatternRule {
    Regex(String),
    ASTPattern(ASTPatternRule),
    Combined(Vec<PatternRule>),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ASTPatternRule {
    pub node_type: String,
    pub conditions: Vec<ASTCondition>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ASTCondition {
    pub field: String,
    pub operator: ConditionOperator,
    pub value: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConditionOperator {
    Equals,
    Contains,
    StartsWith,
    EndsWith,
    Regex,
}

pub struct VulnerabilityPatterns {
    patterns: Vec<VulnerabilityPattern>,
}

impl VulnerabilityPatterns {
    pub fn new() -> Self {
        Self {
            patterns: Self::load_sui_move_patterns(),
        }
    }

    pub fn scan_code(&self, file_path: &str, code: &str) -> Result<Vec<VulnerabilityFinding>> {
        let mut findings = Vec::new();

        for pattern in &self.patterns {
            if let Some(matches) = self.apply_pattern(pattern, file_path, code)? {
                findings.extend(matches);
            }
        }

        Ok(findings)
    }

    fn apply_pattern(
        &self,
        pattern: &VulnerabilityPattern,
        file_path: &str,
        code: &str,
    ) -> Result<Option<Vec<VulnerabilityFinding>>> {
        match &pattern.pattern {
            PatternRule::Regex(regex_str) => {
                self.apply_regex_pattern(pattern, file_path, code, regex_str)
            }
            PatternRule::ASTPattern(_) => {
                // TODO: Implement AST pattern matching
                Ok(None)
            }
            PatternRule::Combined(rules) => {
                let mut all_findings = Vec::new();
                for rule in rules {
                    if let PatternRule::Regex(regex_str) = rule {
                        if let Some(findings) = self.apply_regex_pattern(pattern, file_path, code, regex_str)? {
                            all_findings.extend(findings);
                        }
                    }
                }
                Ok(if all_findings.is_empty() { None } else { Some(all_findings) })
            }
        }
    }

    fn apply_regex_pattern(
        &self,
        pattern: &VulnerabilityPattern,
        file_path: &str,
        code: &str,
        regex_str: &str,
    ) -> Result<Option<Vec<VulnerabilityFinding>>> {
        let regex = Regex::new(regex_str)?;
        let mut findings = Vec::new();

        for (line_number, line) in code.lines().enumerate() {
            if let Some(_captures) = regex.captures(line) {
                let finding = VulnerabilityFinding {
                    id: Uuid::new_v4(),
                    vulnerability_type: pattern.vulnerability_type.clone(),
                    severity: pattern.severity.clone(),
                    confidence_score: pattern.confidence_base,
                    file_path: file_path.to_string(),
                    line_number: Some((line_number + 1) as u32),
                    code_snippet: Some(line.trim().to_string()),
                    description: pattern.description.clone(),
                    recommendation: pattern.recommendation.clone(),
                    cve_id: None,
                    is_false_positive: false,
                };
                findings.push(finding);
            }
        }

        Ok(if findings.is_empty() { None } else { Some(findings) })
    }

    fn load_sui_move_patterns() -> Vec<VulnerabilityPattern> {
        vec![
            // Unauthorized access patterns
            VulnerabilityPattern {
                id: "sui_unauthorized_transfer".to_string(),
                name: "Unauthorized Transfer".to_string(),
                description: "Direct transfer without proper authorization checks".to_string(),
                vulnerability_type: VulnerabilityType::UnauthorizedAccess,
                severity: Severity::High,
                confidence_base: 80.0,
                pattern: PatternRule::Regex(r"coin::transfer".to_string()),
                recommendation: "Add proper authorization checks before transfers".to_string(),
            },

            // Access control patterns
            VulnerabilityPattern {
                id: "sui_missing_capability_check".to_string(),
                name: "Missing Capability Check".to_string(),
                description: "Function missing capability verification".to_string(),
                vulnerability_type: VulnerabilityType::AccessControl,
                severity: Severity::Medium,
                confidence_base: 70.0,
                pattern: PatternRule::Regex(r"public\s+fun\s+\w+.*\{".to_string()),
                recommendation: "Add capability parameter and verification".to_string(),
            },

            // Integer overflow patterns
            VulnerabilityPattern {
                id: "sui_integer_overflow".to_string(),
                name: "Potential Integer Overflow".to_string(),
                description: "Arithmetic operations without overflow protection".to_string(),
                vulnerability_type: VulnerabilityType::IntegerOverflow,
                severity: Severity::Medium,
                confidence_base: 60.0,
                pattern: PatternRule::Regex(r"[+\-*/]\s*\w+".to_string()),
                recommendation: "Use safe arithmetic operations or add overflow checks".to_string(),
            },

            // Logic error patterns
            VulnerabilityPattern {
                id: "sui_unchecked_balance".to_string(),
                name: "Unchecked Balance Operation".to_string(),
                description: "Balance operations without sufficient validation".to_string(),
                vulnerability_type: VulnerabilityType::LogicError,
                severity: Severity::High,
                confidence_base: 75.0,
                pattern: PatternRule::Regex(r"balance::(value|split|join)".to_string()),
                recommendation: "Add balance validation and error handling".to_string(),
            },

            // Timestamp dependence
            VulnerabilityPattern {
                id: "sui_timestamp_dependence".to_string(),
                name: "Timestamp Dependence".to_string(),
                description: "Critical logic dependent on timestamp".to_string(),
                vulnerability_type: VulnerabilityType::TimestampDependence,
                severity: Severity::Medium,
                confidence_base: 65.0,
                pattern: PatternRule::Regex(r"timestamp::now_seconds".to_string()),
                recommendation: "Avoid timestamp-dependent critical logic or add proper validation".to_string(),
            },

            // Resource exhaustion
            VulnerabilityPattern {
                id: "sui_unbounded_vector".to_string(),
                name: "Unbounded Vector Growth".to_string(),
                description: "Vector operations without size limits".to_string(),
                vulnerability_type: VulnerabilityType::ResourceExhaustion,
                severity: Severity::Medium,
                confidence_base: 55.0,
                pattern: PatternRule::Regex(r"vector::(push_back|append)".to_string()),
                recommendation: "Add vector size limits and bounds checking".to_string(),
            },

            // Insufficient validation
            VulnerabilityPattern {
                id: "sui_missing_input_validation".to_string(),
                name: "Missing Input Validation".to_string(),
                description: "Public function without input validation".to_string(),
                vulnerability_type: VulnerabilityType::InsufficientValidation,
                severity: Severity::Medium,
                confidence_base: 50.0,
                pattern: PatternRule::Regex(r"public\s+fun\s+\w+\([^)]+\)\s*\{".to_string()),
                recommendation: "Add comprehensive input validation using assert! statements".to_string(),
            },
        ]
    }

    pub fn add_custom_pattern(&mut self, pattern: VulnerabilityPattern) {
        self.patterns.push(pattern);
    }

    pub fn get_patterns_by_type(&self, vuln_type: &VulnerabilityType) -> Vec<&VulnerabilityPattern> {
        self.patterns
            .iter()
            .filter(|p| std::mem::discriminant(&p.vulnerability_type) == std::mem::discriminant(vuln_type))
            .collect()
    }

    pub fn get_pattern_by_id(&self, id: &str) -> Option<&VulnerabilityPattern> {
        self.patterns.iter().find(|p| p.id == id)
    }

    pub fn get_all_patterns(&self) -> &Vec<VulnerabilityPattern> {
        &self.patterns
    }
}