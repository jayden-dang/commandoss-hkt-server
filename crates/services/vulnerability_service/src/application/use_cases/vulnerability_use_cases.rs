use chrono::Utc;
use std::sync::Arc;
use uuid::Uuid;

use crate::domain::{SeverityLevel, Vulnerability, VulnerabilityFilter, VulnerabilityRepository, VulnerabilityStatus};
use crate::models::*;
use crate::Result;

pub struct VulnerabilityUseCases {
    repository: Arc<dyn VulnerabilityRepository>,
}

impl VulnerabilityUseCases {
    pub fn new(repository: Arc<dyn VulnerabilityRepository>) -> Self {
        Self { repository }
    }

    pub async fn list_vulnerabilities(
        &self,
        request: ListVulnerabilitiesRequest,
    ) -> Result<VulnerabilityListResponse> {
        let page = request.page.unwrap_or(1);
        let limit = request.limit.unwrap_or(20);
        let offset = ((page - 1) * limit) as i64;

        let filter = VulnerabilityFilter {
            repository_id: request.repository_id,
            severity: request.severity,
            status: request.status,
            vulnerability_type: None,
            detected_after: None,
            detected_before: None,
            search_query: None,
        };

        let vulnerabilities = self
            .repository
            .list(&filter, offset, limit as i64)
            .await?;
        let total_count = self.repository.count(&filter).await?;
        let has_more = (offset + limit as i64) < total_count;

        Ok(VulnerabilityListResponse {
            vulnerabilities,
            total_count,
            page,
            limit,
            has_more,
        })
    }

    pub async fn get_vulnerability(&self, id: Uuid) -> Result<Vulnerability> {
        self.repository.get_by_id(id).await
    }

    pub async fn create_vulnerability(&self, vulnerability: &Vulnerability) -> Result<Vulnerability> {
        self.repository.create(vulnerability).await
    }

    pub async fn update_vulnerability(&self, vulnerability: &Vulnerability) -> Result<Vulnerability> {
        self.repository.update(vulnerability).await
    }

    pub async fn update_vulnerability_status(
        &self,
        id: Uuid,
        request: UpdateVulnerabilityStatusRequest,
    ) -> Result<StatusUpdateResponse> {
        let vulnerability = self.repository.get_by_id(id).await?;
        let old_status = vulnerability.status.to_string();

        self.repository
            .update_status(id, request.status.clone(), request.resolved_by)
            .await?;

        // Add to audit trail
        if let Some(resolver) = request.resolved_by {
            self.repository
                .add_status_change(
                    id,
                    vulnerability.status,
                    request.status.clone(),
                    resolver,
                )
                .await?;
        }

        Ok(StatusUpdateResponse {
            vulnerability_id: id,
            old_status,
            new_status: request.status.to_string(),
            updated_by: request.resolved_by,
            updated_at: Utc::now(),
        })
    }

    pub async fn delete_vulnerability(&self, id: Uuid) -> Result<()> {
        self.repository.delete(id).await
    }

    pub async fn get_repository_vulnerabilities(
        &self,
        repository_id: Uuid,
        page: u32,
        limit: u32,
    ) -> Result<VulnerabilityListResponse> {
        let offset = ((page - 1) * limit) as i64;

        let vulnerabilities = self
            .repository
            .get_by_repository(repository_id, offset, limit as i64)
            .await?;

        let filter = VulnerabilityFilter {
            repository_id: Some(repository_id),
            severity: None,
            status: None,
            vulnerability_type: None,
            detected_after: None,
            detected_before: None,
            search_query: None,
        };

        let total_count = self.repository.count(&filter).await?;
        let has_more = (offset + limit as i64) < total_count;

        Ok(VulnerabilityListResponse {
            vulnerabilities,
            total_count,
            page,
            limit,
            has_more,
        })
    }

    pub async fn get_repository_summary(
        &self,
        repository_id: Uuid,
    ) -> Result<VulnerabilitySummaryResponse> {
        let summary = self.repository.get_repository_summary(repository_id).await?;
        
        Ok(VulnerabilitySummaryResponse {
            summary,
            generated_at: Utc::now(),
        })
    }

    pub async fn search_vulnerabilities(
        &self,
        request: SearchVulnerabilitiesRequest,
    ) -> Result<SearchResponse> {
        let limit = request.limit.unwrap_or(20) as i64;
        let vulnerabilities = self.repository.search(&request.query, limit).await?;

        let search_results: Vec<VulnerabilitySearchResult> = vulnerabilities
            .into_iter()
            .map(|v| VulnerabilitySearchResult {
                id: v.id,
                title: v.title,
                repository_name: "Repository".to_string(), // TODO: Join with repositories table
                severity: v.severity.to_string(),
                status: v.status.to_string(),
                match_snippet: v.description.chars().take(200).collect(),
                relevance_score: 0.9, // TODO: Calculate actual relevance
            })
            .collect();

        Ok(SearchResponse {
            total_matches: search_results.len() as i64,
            vulnerabilities: search_results,
            search_query: request.query,
        })
    }

    pub async fn get_vulnerability_types(&self) -> Result<VulnerabilityTypesResponse> {
        let types = self.repository.get_vulnerability_types().await?;
        let total_vulnerabilities: i64 = types.iter().map(|t| t.count).sum();

        Ok(VulnerabilityTypesResponse {
            types,
            total_vulnerabilities,
        })
    }

    pub async fn get_vulnerabilities_by_severity(
        &self,
        severity: String,
        page: u32,
        limit: u32,
    ) -> Result<VulnerabilityListResponse> {
        let offset = ((page - 1) * limit) as i64;
        let severity_level = SeverityLevel::from(severity.clone());

        let vulnerabilities = self
            .repository
            .get_by_severity(severity_level.clone(), offset, limit as i64)
            .await?;

        let filter = VulnerabilityFilter {
            repository_id: None,
            severity: Some(vec![severity_level]),
            status: None,
            vulnerability_type: None,
            detected_after: None,
            detected_before: None,
            search_query: None,
        };

        let total_count = self.repository.count(&filter).await?;
        let has_more = (offset + limit as i64) < total_count;

        Ok(VulnerabilityListResponse {
            vulnerabilities,
            total_count,
            page,
            limit,
            has_more,
        })
    }

    pub async fn bulk_update_vulnerabilities(
        &self,
        request: BulkUpdateVulnerabilitiesRequest,
    ) -> Result<BulkUpdateResponse> {
        let bulk_request = crate::domain::BulkUpdateRequest {
            vulnerability_ids: request.vulnerability_ids,
            status: request.status,
            assigned_to: request.assigned_to,
        };

        let result = self.repository.bulk_update(&bulk_request).await?;

        Ok(BulkUpdateResponse {
            result,
            completed_at: Utc::now(),
        })
    }

    pub async fn export_vulnerabilities(
        &self,
        request: ExportVulnerabilitiesRequest,
    ) -> Result<ExportResponse> {
        let filter = VulnerabilityFilter {
            repository_id: request.repository_id,
            severity: request.severity,
            status: request.status,
            vulnerability_type: None,
            detected_after: None,
            detected_before: None,
            search_query: None,
        };

        let vulnerabilities = self.repository.bulk_export(&filter).await?;
        let vulnerability_count = vulnerabilities.len() as i64;

        // TODO: Implement actual export logic (CSV, PDF generation)
        let export_url = format!("/exports/vulnerabilities_{}.json", Uuid::new_v4());

        Ok(ExportResponse {
            export_url,
            format: match request.format {
                ExportFormat::Json => "json".to_string(),
                ExportFormat::Csv => "csv".to_string(),
                ExportFormat::Pdf => "pdf".to_string(),
            },
            vulnerability_count,
            expires_at: Utc::now() + chrono::Duration::hours(24),
        })
    }
}